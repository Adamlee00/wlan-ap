--- a/drivers/net/wireless/ath/ath11k/ce.c
+++ b/drivers/net/wireless/ath/ath11k/ce.c
@@ -1109,10 +1109,10 @@ void ce_update_tasklet_time_duration_sta
 {
 	s64 sched_us, exec_us;
 
-	sched_us = (ce_pipe->tasklet_ts.exec_entry_ts.tv64 -
-		    ce_pipe->tasklet_ts.sched_entry_ts.tv64);
-	exec_us = (ce_pipe->tasklet_ts.exec_complete_ts.tv64 -
-		   ce_pipe->tasklet_ts.exec_entry_ts.tv64);
+	sched_us = ktime_sub(ce_pipe->tasklet_ts.exec_entry_ts,
+		    ce_pipe->tasklet_ts.sched_entry_ts);
+	exec_us = ktime_sub(ce_pipe->tasklet_ts.exec_complete_ts,
+		   ce_pipe->tasklet_ts.exec_entry_ts);
 
 	sched_us = div_s64(sched_us, CE_TIME_DURATION_USEC * NSEC_PER_USEC);
 	if (sched_us > CE_TIME_DURATION_USEC_500) {
--- a/drivers/net/wireless/ath/ath11k/mac.h
+++ b/drivers/net/wireless/ath/ath11k/mac.h
@@ -8,6 +8,7 @@
 
 #include <net/mac80211.h>
 #include <net/cfg80211.h>
+#include <linux/of.h>
 
 struct ath11k;
 struct ath11k_base;
--- a/drivers/net/wireless/ath/ath11k/qmi.h
+++ b/drivers/net/wireless/ath/ath11k/qmi.h
@@ -6,6 +6,7 @@
 #ifndef ATH11K_QMI_H
 #define ATH11K_QMI_H
 
+#include <linux/device.h>
 #include <linux/mutex.h>
 #include <linux/notifier.h>
 #include <linux/soc/qcom/qmi.h>
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -14,7 +14,6 @@
 #include "qmi.h"
 #include "pci.h"
 #include <linux/remoteproc.h>
-#include <soc/qcom/qgic2m.h>
 
 static const struct of_device_id ath11k_ahb_of_match[] = {
 	/* TODO: Should we change the compatible string to something similar
@@ -615,56 +614,104 @@ static int ath11k_ahb_ext_irq_config(str
 
 static void ath11k_internal_pci_free_irq(struct ath11k_base *ab)
 {
+	struct platform_device *pdev = ab->pdev;
+
 	ath11k_pci_free_irq(ab);
-	qgic2_disable_msi(ab->ipci.qgicm_id);
+	platform_msi_domain_free_irqs(&pdev->dev);
 }
 
-struct qgic2_msi *ath11k_qgic2_enable_msi(struct ath11k_base *ab, int qgicm_id)
+static void ath11k_gicv2m_msg_handler(struct msi_desc *desc, struct msi_msg *msg)
 {
-	struct qgic2_msi *qgic2_msi;
-
-	ab->ipci.msi_cfg = &ath11k_msi_config[ATH11K_MSI_CONFIG_QCN6122];
-	qgic2_msi = qgic2_enable_msi(qgicm_id,
-				     ab->ipci.msi_cfg->total_vectors);
-	if (IS_ERR(qgic2_msi)) {
-		ath11k_err(ab, "qgic2_enable_msi fails %ld\n", PTR_ERR(qgic2_msi));
-		return NULL;
-	}
-
-	return qgic2_msi;
+	desc->msg.address_lo = msg->address_lo;
+	desc->msg.address_hi = msg->address_hi;
+	desc->msg.data = msg->data;
 }
 
 static int ath11k_config_irq_internal_pci(struct ath11k_base *ab)
 {
 	int ret;
+	struct platform_device *pdev = ab->pdev;
+	struct msi_desc *msi_desc;
+	bool ce_done = false;
+	int i = 0;
 
-	if (ab->userpd_id == QCN6122_USERPD_0) {
-		ab->ipci.qgicm_id = APCS_QGIC2M_0;
-	} else if (ab->userpd_id == QCN6122_USERPD_1) {
-		ab->ipci.qgicm_id = APCS_QGIC2M_1;
-	} else {
+	if (ab->userpd_id != QCN6122_USERPD_0 &&
+	    ab->userpd_id != QCN6122_USERPD_1) {
 		ath11k_warn(ab, "ath11k userpd invalid %d\n", ab->userpd_id);
 		return -ENODEV;
 	}
 
-	ab->ipci.qgic2_msi =
-			ath11k_qgic2_enable_msi(ab, ab->ipci.qgicm_id);
-	if (!ab->ipci.qgic2_msi) {
-		ath11k_err(ab, "qgic2_msi fails: dev %d\n", ab->hw_rev);
-		return -ENODEV;
-	}
-	ab->ipci.qgic_enabled = 1;
-	wake_up(&ab->ipci.qgic_msi_waitq);
+	ab->ipci.msi_cfg = &ath11k_msi_config[ATH11K_MSI_CONFIG_QCN6122];
 
-	/* qcn6122 is seen as ahb based device by driver but internallly it is pci
-	 * Hence configuring pci irq for qcn6122
-	 */
-	ret = ath11k_pci_config_qgic_msi_irq(ab);
+	ret = platform_msi_domain_alloc_irqs(&pdev->dev, ab->ipci.msi_cfg->total_vectors,
+					     ath11k_gicv2m_msg_handler);
 	if (ret) {
-		ath11k_err(ab, "internal pci msi configuration failed: dev %d\n",
-			   ab->hw_rev);
-		qgic2_disable_msi(ab->ipci.qgicm_id);
+		ath11k_warn(ab, "failed to alloc irqs %d ab %pM\n", ret, ab);
+		return ret;
+	}
+
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		if (!ce_done && i == ab->hw_params.ce_count) {
+			i = 0;
+			ce_done = true;
+		}
+
+		if (!ce_done && i < ab->hw_params.ce_count) {
+			if (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
+				i++;
+
+			ret = ath11k_pci_config_gic_msi_irq(ab, pdev, msi_desc, i);
+			if (ret) {
+				ath11k_warn(ab, "failed to request irq %d\n", ret);
+				return ret;
+			}
+		} else {
+			ret = ath11k_pci_ext_config_gic_msi_irq(ab, pdev, msi_desc, i);
+			if (ret) {
+				ath11k_warn(ab, "failed to config ext msi irq %d\n", ret);
+				return ret;
+			}
+		}
+
+		i++;
+		ab->ipci.address_lo = msi_desc->msg.address_lo;
+		ab->ipci.address_hi = msi_desc->msg.address_hi;
+
+		if (i == 0 && !ce_done)
+			ab->ipci.gic_ep_base_data = msi_desc->msg.data;
+
 	}
+
+	for_each_msi_entry(msi_desc, &pdev->dev) {
+		u32 user_base_data = 0, base_vector = 0;
+		int vector, num_vectors = 0;
+
+		ret = ath11k_pci_get_user_msi_assignment(ab, ab->ipci.msi_cfg, 0,
+				"DP", &num_vectors, &user_base_data,
+				&base_vector);
+		if (ret < 0)
+			return ret;
+
+		vector = (i % num_vectors) + base_vector;
+
+		if (i >= ATH11K_EXT_IRQ_GRP_NUM_MAX)
+			break;
+
+		if (ab->ipci.dp_irq_num[vector] != msi_desc->irq)
+			continue;
+
+		ret = ath11k_pci_ext_config_gic_msi_irq(ab, pdev, msi_desc, i);
+		if (ret) {
+			ath11k_warn(ab, "failed to config ext msi irq %d\n", ret);
+			return ret;
+		}
+
+		i++;
+	}
+
+	ab->ipci.gic_enabled = 1;
+	wake_up(&ab->ipci.gic_msi_waitq);
+
 	return ret;
 }
 
@@ -778,7 +825,6 @@ static const struct ath11k_hif_ops ath11
 	.config_static_window = ath11k_pci_config_static_window,
 	.free_irq = ath11k_internal_pci_free_irq,
 	.config_irq = ath11k_config_irq_internal_pci,
-	.get_msi_irq = ath11k_pci_get_qgic_msi_irq,
 };
 
 static int ath11k_core_get_rproc(struct ath11k_base *ab)
--- a/drivers/net/wireless/ath/ath11k/ce.h
+++ b/drivers/net/wireless/ath/ath11k/ce.h
@@ -6,6 +6,8 @@
 #ifndef ATH11K_CE_H
 #define ATH11K_CE_H
 
+#define ATH11K_QCN6122_CE_COUNT	6
+
 #define CE_COUNT_MAX 12
 
 /* Byte swap data words */
--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@ -865,10 +865,15 @@ struct ath11k_num_vdevs_peers {
 
 struct ath11k_internal_pci {
 	int qgicm_id;
-	bool qgic_enabled;
-	struct qgic2_msi *qgic2_msi;
 	const struct ath11k_msi_config *msi_cfg;
-	wait_queue_head_t qgic_msi_waitq;
+	bool gic_enabled;
+	wait_queue_head_t gic_msi_waitq;
+	u32 address_lo;
+	u32 address_hi;
+	u32 dp_msi_data[ATH11K_EXT_IRQ_GRP_NUM_MAX];
+	u32 ce_msi_data[ATH11K_QCN6122_CE_COUNT];
+	u32 gic_ep_base_data;
+	u32 dp_irq_num[8];
 };
 
 struct ath11k_memory_stats {
--- a/drivers/net/wireless/ath/ath11k/pci.h
+++ b/drivers/net/wireless/ath/ath11k/pci.h
@@ -6,6 +6,7 @@
 #define _ATH11K_PCI_H
 
 #include <linux/mhi.h>
+#include <linux/msi.h>
 
 #include "core.h"
 
@@ -169,7 +170,10 @@ int ath11k_pci_get_user_msi_assignment(s
 int ath11k_pci_get_msi_irq(struct ath11k_base *ab, unsigned int vector);
 void ath11k_pci_write32(struct ath11k_base *ab, u32 offset, u32 value);
 u32 ath11k_pci_read32(struct ath11k_base *ab, u32 offset);
-int ath11k_pci_config_qgic_msi_irq(struct ath11k_base *ab);
+int ath11k_pci_ext_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+		struct msi_desc *msi_desc, int i);
+int ath11k_pci_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+		struct msi_desc *msi_desc, int i);
 int ath11k_pci_start(struct ath11k_base *ab);
 void ath11k_pci_stop(struct ath11k_base *ab);
 void ath11k_pci_ext_irq_enable(struct ath11k_base *ab);
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2019-2020 The Linux Foundation. All rights reserved.
  */
 
+#include <linux/platform_device.h>
 #include <linux/module.h>
 #include <linux/msi.h>
 #include <linux/pci.h>
@@ -14,8 +15,6 @@
 #include "debug.h"
 #include "qmi.h"
 #include <linux/of.h>
-#include <soc/qcom/qgic2m.h>
-
 
 #define ATH11K_PCI_BAR_NUM		0
 #define ATH11K_PCI_DMA_MASK		32
@@ -438,23 +437,6 @@ static void ath11k_pci_sw_reset(struct a
 
 #define MAX_MSI_IRQS            32
 
-int ath11k_pci_get_qgic_msi_irq(struct ath11k_base *ab, unsigned int vector)
-{
-	struct qgic2_msi *qgic2_msi = ab->ipci.qgic2_msi;
-
-	if (!qgic2_msi) {
-		ath11k_err(ab, "qgic2_msi is NULL\n");
-		return -EINVAL;
-	}
-
-	if (vector >= MAX_MSI_IRQS) {
-		ath11k_err(ab, "irq vector greater than MAX MSI IRQ\n");
-		return -EINVAL;
-	}
-	return qgic2_msi->msi[vector];
-}
-EXPORT_SYMBOL(ath11k_pci_get_qgic_msi_irq);
-
 int ath11k_pci_get_msi_irq(struct ath11k_base *ab, unsigned int vector)
 {
 	struct device *dev = ab->dev;
@@ -483,13 +465,7 @@ void ath11k_pci_get_msi_address(struct a
 void ath11k_pci_get_qgic_msi_address(struct ath11k_base *ab, u32 *msi_addr_lo,
 				     u32 *msi_addr_hi)
 {
-	struct qgic2_msi *qgic2_msi = ab->ipci.qgic2_msi;
-
-	if (!qgic2_msi) {
-		ath11k_err(ab, "qgic2_msi is NULL\n");
-		return;
-	}
-	*msi_addr_lo = qgic2_msi->msi_gicm_addr;
+	*msi_addr_lo = ab->ipci.address_lo;
 	*msi_addr_hi = 0;
 }
 EXPORT_SYMBOL(ath11k_pci_get_qgic_msi_address);
@@ -521,6 +497,7 @@ int ath11k_pci_get_user_msi_assignment(s
 
 	return -EINVAL;
 }
+EXPORT_SYMBOL(ath11k_pci_get_user_msi_assignment);
 
 void ath11k_pci_get_ce_msi_idx(struct ath11k_base *ab, u32 ce_id,
 			       u32 *msi_idx)
@@ -557,13 +534,7 @@ int ath11k_get_user_qgic_msi_assignment(
 					int *num_vectors, u32 *user_base_data,
 					u32 *base_vector)
 {
-	struct qgic2_msi *qgic2_msi = ab->ipci.qgic2_msi;
-	struct ath11k_msi_config *msi_cfg = ab->ipci.msi_cfg;
-
-	return ath11k_pci_get_user_msi_assignment(ab, msi_cfg,
-						  qgic2_msi->msi_gicm_base, user_name,
-						  num_vectors, user_base_data,
-						  base_vector);
+	return 0;
 }
 EXPORT_SYMBOL(ath11k_get_user_qgic_msi_assignment);
 
@@ -929,6 +900,96 @@ static int ath11k_config_msi_irq(struct
 	return 0;
 }
 
+int ath11k_pci_ext_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+		struct msi_desc *msi_desc, int i)
+{
+	u32 user_base_data = 0, base_vector = 0, base_idx;
+	struct ath11k_ext_irq_grp *irq_grp;
+	int j, ret = 0, num_vectors = 0;
+	u8 domain_id;
+	u32 num_irq = 0;
+
+	domain_id = ath11k_pci_get_domain_id(ab);
+	base_idx = ATH11K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;
+	ret = ath11k_pci_get_user_msi_assignment(ab, ab->ipci.msi_cfg, 0,
+			"DP", &num_vectors, &user_base_data,
+			&base_vector);
+	if (ret < 0)
+		return ret;
+
+	irq_grp = &ab->ext_irq_grp[i];
+	irq_grp->ab = ab;
+	irq_grp->grp_id = i;
+	init_dummy_netdev(&irq_grp->napi_ndev);
+	netif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,
+			ath11k_pci_ext_grp_napi_poll, NAPI_POLL_WEIGHT);
+
+	if (ab->hw_params.ring_mask->tx[i] ||
+			ab->hw_params.ring_mask->rx[i] ||
+			ab->hw_params.ring_mask->rx_err[i] ||
+			ab->hw_params.ring_mask->rx_wbm_rel[i] ||
+			ab->hw_params.ring_mask->reo_status[i] ||
+			ab->hw_params.ring_mask->rxdma2host[i] ||
+			ab->hw_params.ring_mask->host2rxdma[i] ||
+			ab->hw_params.ring_mask->rx_mon_status[i]) {
+		num_irq = 1;
+	}
+
+	irq_grp->num_irq = num_irq;
+	irq_grp->irqs[0] = base_idx + i;
+
+	for (j = 0; j < irq_grp->num_irq; j++) {
+
+		int irq_idx = irq_grp->irqs[j];
+		int vector = (i % num_vectors) + base_vector;
+
+		irq_set_status_flags(msi_desc->irq, IRQ_DISABLE_UNLAZY);
+		ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+				ath11k_pci_ext_interrupt_handler,
+				IRQF_SHARED, dp_irq_name[domain_id][i],
+				irq_grp);
+		if (ret) {
+			ath11k_err(ab, "failed request irq %d: %d\n",
+					irq_idx, ret);
+			return ret;
+		}
+		ab->irq_num[irq_idx] = msi_desc->irq;
+		ab->ipci.dp_irq_num[vector] = msi_desc->irq;
+		ab->ipci.dp_msi_data[i] = msi_desc->msg.data;
+		disable_irq_nosync(ab->irq_num[irq_idx]);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(ath11k_pci_ext_config_gic_msi_irq);
+
+int ath11k_pci_config_gic_msi_irq(struct ath11k_base *ab, struct platform_device *pdev,
+		struct msi_desc *msi_desc, int i)
+{
+	struct ath11k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];
+	int irq_idx, ret;
+	u8 domain_id;
+
+	domain_id = ath11k_pci_get_domain_id(ab);
+	tasklet_setup(&ce_pipe->intr_tq, ath11k_pci_ce_tasklet);
+	irq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;
+
+	ret = devm_request_irq(&pdev->dev, msi_desc->irq,
+			ath11k_pci_ce_interrupt_handler,
+			IRQF_SHARED, ce_irq_name[domain_id][i],
+			ce_pipe);
+	if (ret) {
+		ath11k_warn(ab, "failed to request irq %d: %d\n",
+				irq_idx, ret);
+		return ret;
+	}
+	ab->irq_num[irq_idx] = msi_desc->irq;
+	ab->ipci.ce_msi_data[i] = msi_desc->msg.data;
+	ath11k_pci_ce_irq_disable(ab, i);
+
+	return ret;
+}
+EXPORT_SYMBOL(ath11k_pci_config_gic_msi_irq);
+
 static int ath11k_pci_config_irq(struct ath11k_base *ab)
 {
 	int ret;
@@ -979,7 +1040,11 @@ static int ath11k_pci_enable_msi(struct
 	num_vectors = pci_alloc_irq_vectors(ab_pci->pdev,
 					    msi_config->total_vectors,
 					    msi_config->total_vectors,
+#if LINUX_VERSION_IS_LESS(5,4,0)
 					    PCI_IRQ_NOMSIX);
+#elif LINUX_VERSION_IS_GEQ(5,4,0)
+					    PCI_IRQ_LEGACY|PCI_IRQ_MSI);
+#endif
 	if (num_vectors != msi_config->total_vectors) {
 		ath11k_err(ab, "failed to get %d MSI vectors, only %d available",
 			   msi_config->total_vectors, num_vectors);
@@ -1318,18 +1383,6 @@ static const struct ath11k_hif_ops ath11
 	.get_msi_irq = ath11k_pci_get_msi_irq,
 };
 
-int ath11k_pci_config_qgic_msi_irq(struct ath11k_base *ab)
-{
-	int ret = 0;
-	struct qgic2_msi *qgic2_msi = ab->ipci.qgic2_msi;
-	struct ath11k_msi_config *msi_cfg = ab->ipci.msi_cfg;
-
-	ret = ath11k_config_msi_irq(ab, msi_cfg,
-				    qgic2_msi->msi_gicm_base);
-	return ret;
-}
-EXPORT_SYMBOL(ath11k_pci_config_qgic_msi_irq);
-
 static int ath11k_pci_probe(struct pci_dev *pdev,
 			    const struct pci_device_id *pci_dev)
 {
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -4427,18 +4427,18 @@ static const struct qmi_ops ath11k_qmi_o
 	.del_server = ath11k_qmi_ops_del_server,
 };
 
-static int ath11k_wait_for_qgic_msi(struct ath11k_base *ab)
+static int ath11k_wait_for_gic_msi(struct ath11k_base *ab)
 {
 	int timeout;
 
 	if (ab->hw_rev != ATH11K_HW_QCN6122)
 		return 0;
 
-	timeout = wait_event_timeout(ab->ipci.qgic_msi_waitq,
-				     (ab->ipci.qgic_enabled == 1),
+	timeout = wait_event_timeout(ab->ipci.gic_msi_waitq,
+				     (ab->ipci.gic_enabled == 1),
 				     ATH11K_RCV_QGIC_MSI_HDLR_DELAY);
 	if (timeout <= 0) {
-		ath11k_warn(ab, "Receive qgic msi handler timed out\n");
+		ath11k_warn(ab, "Receive gic msi handler timed out\n");
 		return -ETIMEDOUT;
 	}
 	return 0;
@@ -4497,10 +4497,10 @@ static void ath11k_qmi_driver_event_work
 				clear_bit(ATH11K_FLAG_CRASH_FLUSH,
 					  &ab->dev_flags);
 				clear_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags);
-				ret = ath11k_wait_for_qgic_msi(ab);
+				ret = ath11k_wait_for_gic_msi(ab);
 				if (ret) {
 					ath11k_warn(ab,
-					"Failed to get qgic handler for dev %d ret: %d\n",
+					"Failed to get gic handler for dev %d ret: %d\n",
 									ab->hw_rev, ret);
 					break;
 				}
@@ -4626,7 +4626,7 @@ int ath11k_qmi_init_service(struct ath11
 		destroy_workqueue(ab->qmi.event_wq);
 		return ret;
 	}
-	init_waitqueue_head(&ab->ipci.qgic_msi_waitq);
+	init_waitqueue_head(&ab->ipci.gic_msi_waitq);
 	return ret;
 }
 
--- a/drivers/net/wireless/ath/ath11k/coredump.c
+++ b/drivers/net/wireless/ath/ath11k/coredump.c
@@ -174,7 +174,11 @@ void ath11k_coredump_download_rddm(struc
 	struct ath11k_dump_segment *segment, *seg_info;
 	int i, rem_seg_cnt = 0, len, num_seg, seg_sz, qdss_seg_cnt = 1;
 
+#if LINUX_VERSION_IS_LESS(5,4,0)
 	mhi_download_rddm_img(mhi_ctrl, false);
+#elif LINUX_VERSION_IS_GEQ(5,4,0)
+	mhi_download_rddm_image(mhi_ctrl, false);
+#endif
 
 	rddm_img = mhi_ctrl->rddm_image;
 	fw_img = mhi_ctrl->fbc_image;
