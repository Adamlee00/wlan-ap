--- a/drivers/net/phy/rtl8367b.c
+++ b/drivers/net/phy/rtl8367b.c
@@ -185,6 +185,22 @@
 #define RTL8367B_RTL_MAGIC_ID_REG		0x13c2
 #define   RTL8367B_RTL_MAGIC_ID_VAL		0x0249
 
+#define RTL8367S_EXT_TXC_DLY_REG		0x13f9
+#define   RTL8367S_EXT1_GMII_TX_DELAY_SHIFT	12
+#define   RTL8367S_EXT0_GMII_TX_DELAY_SHIFT	9
+#define   RTL8367S_EXT_GMII_TX_DELAY_MASK	GENMASK(2,0)
+
+#define RTL8367S_SDS_MISC			0x1d11
+#define   RTL8367S_CFG_SGMII_RXFC		BIT(14)
+#define   RTL8367S_CFG_SGMII_TXFC		BIT(13)
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT	11
+#define   RTL8367S_CFG_MAC8_SEL_HSGMII_MASK	BIT(11)
+#define   RTL8367S_CFG_SGMII_FDUP		BIT(10)
+#define   RTL8367S_CFG_SGMII_LINK		BIT(9)
+#define   RTL8367S_CFG_SGMII_SPD_SHIFT		7
+#define   RTL8367S_CFG_SGMII_SPD_MASK		GENMASK(8,7)
+#define   RTL8367S_CFG_MAC8_SEL_SGMII		BIT(6)
+
 #define RTL8367B_IA_CTRL_REG			0x1f00
 #define   RTL8367B_IA_CTRL_RW(_x)		((_x) << 1)
 #define   RTL8367B_IA_CTRL_RW_READ		RTL8367B_IA_CTRL_RW(0)
@@ -202,9 +218,18 @@
 
 #define RTL8367B_INTERNAL_PHY_REG(_a, _r)	(0x2000 + 32 * (_a) + (_r))
 
+/* SerDes indirect access */
+#define RTL8367S_SDS_INDACS_CMD_REG		0x6600
+#define   RTL8367S_SDS_CMD			BIT(7)
+#define   RTL8367S_SDS_RWOP			BIT(6)
+#define RTL8367S_SDS_INDACS_ADDR_REG		0x6601
+#define RTL8367S_SDS_INDACS_DATA_REG		0x6602
+
 #define RTL8367B_NUM_MIB_COUNTERS	58
 
+#define RTL8367S_PHY_ADDR		29
 #define RTL8367B_CPU_PORT_NUM		5
+#define RTL8367S_CPU_PORT_NUM		6
 #define RTL8367B_NUM_PORTS		8
 #define RTL8367B_NUM_VLANS		32
 #define RTL8367B_NUM_VIDS		4096
@@ -220,6 +245,9 @@
 #define RTL8367B_PORT_E1		BIT(6)	/* External port 1 */
 #define RTL8367B_PORT_E2		BIT(7)	/* External port 2 */
 
+#define RTL8367B_MIB_RXB_ID		0	/* IfInOctets */
+#define RTL8367B_MIB_TXB_ID		28	/* IfOutOctets */
+
 #define RTL8367B_PORTS_ALL					\
 	(RTL8367B_PORT_0 | RTL8367B_PORT_1 | RTL8367B_PORT_2 |	\
 	 RTL8367B_PORT_3 | RTL8367B_PORT_4 | RTL8367B_PORT_E0 | \
@@ -229,6 +257,433 @@
 	(RTL8367B_PORT_0 | RTL8367B_PORT_1 | RTL8367B_PORT_2 |	\
 	 RTL8367B_PORT_3 | RTL8367B_PORT_4 | RTL8367B_PORT_E1 |	\
 	 RTL8367B_PORT_E2)
+	 
+#define    RTL8367S_REG_SDS_MISC    0x1d11
+#define    RTL8367S_CFG_MAC8_SEL_SGMII_OFFSET    6
+#define    RTL8367S_CFG_MAC8_SEL_HSGMII_OFFSET    11
+#define    RTL8367S_CFG_SGMII_FDUP_OFFSET    10
+//#define    RTL8367S_CFG_SGMII_SPD_MASK    0x180
+#define    RTL8367S_CFG_SGMII_LINK_OFFSET    9
+#define    RTL8367S_CFG_SGMII_TXFC_OFFSET    13
+#define    RTL8367S_CFG_SGMII_RXFC_OFFSET    14
+#define    RTL8367S_REG_DIGITAL_INTERFACE0_FORCE    0x1310
+#define    RTL8367S_REG_DIGITAL_INTERFACE2_FORCE    0x13c4
+
+#define    RTL8367S_REG_REG_TO_ECO4    0x1d41
+#define    RTL8367S_REG_CHIP_RESET    0x1322
+
+#define    RTL8367S_DW8051_RST_OFFSET    4
+#define    RTL8367S_REG_MISCELLANEOUS_CONFIGURE0    0x130c
+#define    RTL8367S_REG_MISCELLANEOUS_CONFIGURE0    0x130c
+#define    RTL8367S_REG_DW8051_RDY    0x1336
+#define    RTL8367S_ACS_IROM_ENABLE_OFFSET    1
+#define    RTL8367S_IROM_MSB_OFFSET    2
+
+#define    RTL8367S_REG_BYPASS_LINE_RATE    0x03f7
+
+#define    RTL8367S_REG_SDS_INDACS_DATA    0x6602
+#define    RTL8367S_REG_SDS_INDACS_ADR    0x6601
+
+#define    RTL8367S_REG_SDS_INDACS_CMD    0x6600
+
+#define    RTL8367S_REG_DIGITAL_INTERFACE_SELECT    0x1305
+#define    RTL8367S_SELECT_GMII_0_MASK    0xF
+#define    RTL8367S_SELECT_GMII_1_OFFSET    4
+#define    RTL8367S_REG_DIGITAL_INTERFACE_SELECT_1    0x13c3
+#define    RTL8367S_SELECT_GMII_2_MASK    0xF
+
+#define    RTL8367S_DW8051_EN_OFFSET    5
+#define SGMII_INIT_SIZE 1223
+u8 Sgmii_Init[SGMII_INIT_SIZE] = {
+0x02,0x03,0xA9,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x04,0x35,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0xE4,0x90,0x06,0x28,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x04,0x93,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x04,0x93,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,
+0x49,0x7E,0x13,0x12,0x04,0x93,0x12,0x04,
+0xBA,0x7D,0xFE,0x7C,0x00,0x7F,0xAA,0x7E,
+0x12,0x12,0x04,0x93,0x7D,0x41,0x7C,0x00,
+0x7F,0x36,0x7E,0x13,0x12,0x04,0x93,0xE4,
+0xFF,0xFE,0xFD,0x80,0x25,0xE4,0x7F,0x20,
+0x7E,0x4E,0xFD,0xFC,0x90,0x06,0x24,0x12,
+0x01,0x0F,0xC3,0x12,0x00,0xF2,0x50,0x1B,
+0x90,0x06,0x24,0x12,0x01,0x03,0xEF,0x24,
+0x01,0xFF,0xE4,0x3E,0xFE,0xE4,0x3D,0xFD,
+0xE4,0x3C,0xFC,0x90,0x06,0x24,0x12,0x01,
+0x1B,0x80,0xD2,0xC2,0x00,0xC2,0x01,0xD2,
+0xA9,0xD2,0x8C,0x7D,0x3D,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x93,0x7D,0x80,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,
+0x93,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6F,
+0x7F,0x02,0x7E,0x66,0x12,0x04,0x6F,0xEF,
+0x30,0xE4,0x07,0xE4,0x90,0x06,0x28,0xF0,
+0x80,0xD1,0x90,0x06,0x28,0xE0,0x70,0x12,
+0x12,0x03,0x03,0x90,0x06,0x28,0x74,0x01,
+0xF0,0xE4,0x90,0x06,0x2B,0xF0,0xA3,0xF0,
+0x80,0xB9,0xC3,0x90,0x06,0x2C,0xE0,0x94,
+0x62,0x90,0x06,0x2B,0xE0,0x94,0x00,0x40,
+0xAA,0xE4,0xF0,0xA3,0xF0,0x12,0x03,0x03,
+0x90,0x06,0x28,0x74,0x01,0xF0,0x80,0x9B,
+0x75,0x0F,0x80,0x75,0x0E,0x7E,0x75,0x0D,
+0xAA,0x75,0x0C,0x83,0xE4,0xF5,0x10,0x7F,
+0x36,0x7E,0x13,0x12,0x04,0x6F,0xEE,0xC4,
+0xF8,0x54,0xF0,0xC8,0xEF,0xC4,0x54,0x0F,
+0x48,0x54,0x07,0xFB,0x7A,0x00,0xEA,0x70,
+0x4A,0xEB,0x14,0x60,0x1C,0x14,0x60,0x27,
+0x24,0xFE,0x60,0x31,0x14,0x60,0x3C,0x24,
+0x05,0x70,0x38,0x75,0x0B,0x00,0x75,0x0A,
+0xC2,0x75,0x09,0xEB,0x75,0x08,0x0B,0x80,
+0x36,0x75,0x0B,0x40,0x75,0x0A,0x59,0x75,
+0x09,0x73,0x75,0x08,0x07,0x80,0x28,0x75,
+0x0B,0x00,0x75,0x0A,0xE1,0x75,0x09,0xF5,
+0x75,0x08,0x05,0x80,0x1A,0x75,0x0B,0xA0,
+0x75,0x0A,0xAC,0x75,0x09,0xB9,0x75,0x08,
+0x03,0x80,0x0C,0x75,0x0B,0x00,0x75,0x0A,
+0x62,0x75,0x09,0x3D,0x75,0x08,0x01,0x75,
+0x89,0x11,0xE4,0x7B,0x60,0x7A,0x09,0xF9,
+0xF8,0xAF,0x0B,0xAE,0x0A,0xAD,0x09,0xAC,
+0x08,0x12,0x00,0x60,0xAA,0x06,0xAB,0x07,
+0xC3,0xE4,0x9B,0xFB,0xE4,0x9A,0xFA,0x78,
+0x17,0xF6,0xAF,0x03,0xEF,0x08,0xF6,0x18,
+0xE6,0xF5,0x8C,0x08,0xE6,0xF5,0x8A,0x74,
+0x0D,0x2B,0xFB,0xE4,0x3A,0x18,0xF6,0xAF,
+0x03,0xEF,0x08,0xF6,0x75,0x88,0x10,0x53,
+0x8E,0xC7,0xD2,0xA9,0x22,0x7D,0x02,0x7C,
+0x00,0x7F,0x4A,0x7E,0x13,0x12,0x04,0x93,
+0x7D,0x46,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x04,0x93,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,
+0x93,0xE4,0xFF,0xFE,0x0F,0xBF,0x00,0x01,
+0x0E,0xEF,0x64,0x64,0x4E,0x70,0xF5,0x7D,
+0x04,0x7C,0x00,0x7F,0x02,0x7E,0x66,0x12,
+0x04,0x93,0x7D,0x00,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,0x93,
+0xE4,0xFD,0xFC,0x7F,0x02,0x7E,0x66,0x12,
+0x04,0x93,0x7D,0x00,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x04,0x93,
+0xE4,0xFD,0xFC,0x7F,0x4A,0x7E,0x13,0x12,
+0x04,0x93,0x7D,0x06,0x7C,0x71,0x7F,0x02,
+0x7E,0x66,0x12,0x04,0x93,0x7D,0x03,0x7C,
+0x00,0x7F,0x01,0x7E,0x66,0x12,0x04,0x93,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x02,0x04,0x93,0x78,0x7F,0xE4,0xF6,0xD8,
+0xFD,0x75,0x81,0x3C,0x02,0x03,0xF0,0x02,
+0x01,0x27,0xE4,0x93,0xA3,0xF8,0xE4,0x93,
+0xA3,0x40,0x03,0xF6,0x80,0x01,0xF2,0x08,
+0xDF,0xF4,0x80,0x29,0xE4,0x93,0xA3,0xF8,
+0x54,0x07,0x24,0x0C,0xC8,0xC3,0x33,0xC4,
+0x54,0x0F,0x44,0x20,0xC8,0x83,0x40,0x04,
+0xF4,0x56,0x80,0x01,0x46,0xF6,0xDF,0xE4,
+0x80,0x0B,0x01,0x02,0x04,0x08,0x10,0x20,
+0x40,0x80,0x90,0x04,0xAF,0xE4,0x7E,0x01,
+0x93,0x60,0xBC,0xA3,0xFF,0x54,0x3F,0x30,
+0xE5,0x09,0x54,0x1F,0xFE,0xE4,0x93,0xA3,
+0x60,0x01,0x0E,0xCF,0x54,0xC0,0x25,0xE0,
+0x60,0xA8,0x40,0xB8,0xE4,0x93,0xA3,0xFA,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xF0,
+0xA3,0xC8,0xC5,0x82,0xC8,0xCA,0xC5,0x83,
+0xCA,0xDF,0xE9,0xDE,0xE7,0x80,0xBE,0xC0,
+0xE0,0xC0,0xF0,0xC0,0x83,0xC0,0x82,0xC0,
+0xD0,0x75,0xD0,0x00,0xC0,0x00,0x78,0x17,
+0xE6,0xF5,0x8C,0x78,0x18,0xE6,0xF5,0x8A,
+0x90,0x06,0x29,0xE4,0x75,0xF0,0x01,0x12,
+0x00,0x0E,0x90,0x06,0x2B,0xE4,0x75,0xF0,
+0x01,0x12,0x00,0x0E,0xD0,0x00,0xD0,0xD0,
+0xD0,0x82,0xD0,0x83,0xD0,0xF0,0xD0,0xE0,
+0x32,0xC2,0xAF,0xAD,0x07,0xAC,0x06,0x8C,
+0xA2,0x8D,0xA3,0x75,0xA0,0x01,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0xAE,0xA1,0xBE,0x00,0xF0,0xAE,0xA6,
+0xAF,0xA7,0xD2,0xAF,0x22,0xC2,0xAF,0xAB,
+0x07,0xAA,0x06,0x8A,0xA2,0x8B,0xA3,0x8C,
+0xA4,0x8D,0xA5,0x75,0xA0,0x03,0x00,0x00,
+0x00,0xAA,0xA1,0xBA,0x00,0xF8,0xD2,0xAF,
+0x22,0x42,0x06,0x2B,0x00,0x00,0x42,0x06,
+0x29,0x00,0x00,0x00,0x12,0x04,0xC3,0x12,
+0x02,0x3E,0x02,0x00,0x03,0xE4,0xF5,0x8E,
+0x22};
+
+#define FIBER2_1G_INIT_SIZE 1842
+u8 Fiber2_1G[FIBER2_1G_INIT_SIZE] = {
+0x02,0x05,0x97,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x22,0x00,0x00,0x02,0x06,0x89,
+0xC5,0xF0,0xF8,0xA3,0xE0,0x28,0xF0,0xC5,
+0xF0,0xF8,0xE5,0x82,0x15,0x82,0x70,0x02,
+0x15,0x83,0xE0,0x38,0xF0,0x22,0x75,0xF0,
+0x08,0x75,0x82,0x00,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xCD,0x33,0xCD,0xCC,0x33,0xCC,
+0xC5,0x82,0x33,0xC5,0x82,0x9B,0xED,0x9A,
+0xEC,0x99,0xE5,0x82,0x98,0x40,0x0C,0xF5,
+0x82,0xEE,0x9B,0xFE,0xED,0x9A,0xFD,0xEC,
+0x99,0xFC,0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,
+0xFB,0xE4,0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,
+0x82,0x22,0xB8,0x00,0xC1,0xB9,0x00,0x59,
+0xBA,0x00,0x2D,0xEC,0x8B,0xF0,0x84,0xCF,
+0xCE,0xCD,0xFC,0xE5,0xF0,0xCB,0xF9,0x78,
+0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,
+0x33,0xFD,0xEC,0x33,0xFC,0xEB,0x33,0xFB,
+0x10,0xD7,0x03,0x99,0x40,0x04,0xEB,0x99,
+0xFB,0x0F,0xD8,0xE5,0xE4,0xF9,0xFA,0x22,
+0x78,0x18,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xEC,0x33,0xFC,0xC9,0x33,
+0xC9,0x10,0xD7,0x05,0x9B,0xE9,0x9A,0x40,
+0x07,0xEC,0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,
+0xD8,0xE0,0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,
+0x22,0x75,0xF0,0x10,0xEF,0x2F,0xFF,0xEE,
+0x33,0xFE,0xED,0x33,0xFD,0xCC,0x33,0xCC,
+0xC8,0x33,0xC8,0x10,0xD7,0x07,0x9B,0xEC,
+0x9A,0xE8,0x99,0x40,0x0A,0xED,0x9B,0xFD,
+0xEC,0x9A,0xFC,0xE8,0x99,0xF8,0x0F,0xD5,
+0xF0,0xDA,0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,
+0xE4,0xC8,0xF9,0x22,0xEB,0x9F,0xF5,0xF0,
+0xEA,0x9E,0x42,0xF0,0xE9,0x9D,0x42,0xF0,
+0xE8,0x9C,0x45,0xF0,0x22,0xE0,0xFC,0xA3,
+0xE0,0xFD,0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,
+0x22,0xE0,0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,
+0xFA,0xA3,0xE0,0xFB,0x22,0xEC,0xF0,0xA3,
+0xED,0xF0,0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,
+0x22,0x7D,0xD7,0x7C,0x04,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x04,
+0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x94,0x7C,0xF9,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x81,0x7C,
+0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xA2,0x7C,0x31,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x82,
+0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x60,0x7C,0x69,
+0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x83,0x7C,0x04,0x7F,0x01,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,0x00,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0x28,0x7C,
+0x97,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x84,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x85,
+0x7C,0x9D,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x23,0x7C,0x04,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,
+0x10,0x7C,0xD8,0x7F,0x02,0x7E,0x66,0x12,
+0x06,0xE7,0x7D,0x24,0x7C,0x04,0x7F,0x01,
+0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,
+0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x2F,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,
+0x40,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,
+0x02,0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,
+0xBF,0xFD,0xAC,0x06,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x54,0xFD,
+0x54,0xFE,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x12,0x06,
+0xE7,0xE4,0xFD,0xFC,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x80,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7F,0x02,
+0x7E,0x66,0x12,0x06,0xC3,0xEF,0x44,0x02,
+0x44,0x01,0xFD,0xAC,0x06,0x7F,0x02,0x7E,
+0x66,0x12,0x06,0xE7,0xE4,0xFD,0xFC,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0xE4,0x90,0x06,0x2C,0xF0,0xFD,0x7C,
+0x01,0x7F,0x3F,0x7E,0x1D,0x12,0x06,0xE7,
+0x7D,0x40,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xE4,
+0xF5,0xA8,0xD2,0xAF,0x12,0x07,0x17,0x7D,
+0xFE,0x7C,0x00,0x7F,0xAA,0x7E,0x12,0x12,
+0x06,0xE7,0x12,0x01,0x27,0x12,0x06,0x23,
+0x7D,0x41,0x7C,0x00,0x7F,0x36,0x7E,0x13,
+0x12,0x06,0xE7,0xE4,0xFF,0xFE,0xFD,0x80,
+0x25,0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,
+0x90,0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,
+0x00,0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,
+0x01,0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,
+0xFE,0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x1B,0x80,0xD2,0xC2,
+0x00,0xC2,0x01,0xD2,0xA9,0xD2,0x8C,0x7F,
+0x01,0x7E,0x62,0x12,0x06,0xC3,0x7F,0x01,
+0x7E,0x62,0x12,0x06,0xC3,0xEF,0x30,0xE2,
+0x07,0xE4,0x90,0x06,0x2C,0xF0,0x80,0xE7,
+0x90,0x06,0x2C,0xE0,0x70,0x12,0x12,0x04,
+0xF1,0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,
+0x90,0x06,0x33,0xF0,0xA3,0xF0,0x80,0xCF,
+0xC3,0x90,0x06,0x34,0xE0,0x94,0x62,0x90,
+0x06,0x33,0xE0,0x94,0x00,0x40,0xC0,0xE4,
+0xF0,0xA3,0xF0,0x12,0x04,0xF1,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0x80,0xB1,0x75,0x0F,
+0x80,0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,
+0x0C,0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,
+0x13,0x12,0x06,0xC3,0xEE,0xC4,0xF8,0x54,
+0xF0,0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,
+0x07,0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,
+0x14,0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,
+0x60,0x31,0x14,0x60,0x3C,0x24,0x05,0x70,
+0x38,0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,
+0x09,0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,
+0x0B,0x40,0x75,0x0A,0x59,0x75,0x09,0x73,
+0x75,0x08,0x07,0x80,0x28,0x75,0x0B,0x00,
+0x75,0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,
+0x05,0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,
+0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,0x80,
+0x0C,0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,
+0x09,0x3D,0x75,0x08,0x01,0x75,0x89,0x11,
+0xE4,0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,
+0x0B,0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,
+0x00,0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,
+0x9B,0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,
+0xAF,0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,
+0x8C,0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,
+0xFB,0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,
+0xD2,0xA9,0x22,0x7D,0x02,0x7C,0x00,0x7F,
+0x4A,0x7E,0x13,0x12,0x06,0xE7,0x7D,0x46,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x06,
+0xE7,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,
+0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,
+0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,
+0x00,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0xE4,0xFD,
+0xFC,0x7F,0x4A,0x7E,0x13,0x12,0x06,0xE7,
+0x7D,0x06,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x06,0xE7,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x06,
+0xE7,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x05,0xDE,0x02,0x03,0x2F,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x07,0x23,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0x7D,0xD7,0x7C,
+0x04,0x7F,0x02,0x7E,0x66,0x12,0x06,0xE7,
+0x7D,0x80,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x06,0xE7,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x06,0xE7,0x7D,0x40,
+0x7C,0x17,0x7F,0x11,0x7E,0x1D,0x12,0x06,
+0xE7,0x7D,0xBB,0x7C,0x15,0x7F,0xEB,0x7E,
+0x13,0x12,0x06,0xE7,0x7D,0x0C,0x7C,0x00,
+0x7F,0xE7,0x7E,0x13,0x12,0x06,0xE7,0x7F,
+0x41,0x7E,0x1D,0x12,0x06,0xC3,0xEF,0x44,
+0x20,0x44,0x80,0xFD,0xAC,0x06,0x7F,0x41,
+0x7E,0x1D,0x12,0x06,0xE7,0x7D,0x40,0x7C,
+0x01,0x7F,0x00,0x7E,0x62,0x12,0x06,0xE7,
+0x02,0x02,0x2F,0xC0,0xE0,0xC0,0xF0,0xC0,
+0x83,0xC0,0x82,0xC0,0xD0,0x75,0xD0,0x00,
+0xC0,0x00,0x78,0x17,0xE6,0xF5,0x8C,0x78,
+0x18,0xE6,0xF5,0x8A,0x90,0x06,0x31,0xE4,
+0x75,0xF0,0x01,0x12,0x00,0x0E,0x90,0x06,
+0x33,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0xD0,0x00,0xD0,0xD0,0xD0,0x82,0xD0,0x83,
+0xD0,0xF0,0xD0,0xE0,0x32,0xC2,0xAF,0xAD,
+0x07,0xAC,0x06,0x8C,0xA2,0x8D,0xA3,0x75,
+0xA0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0xAE,0xA1,0xBE,
+0x00,0xF0,0xAE,0xA6,0xAF,0xA7,0xD2,0xAF,
+0x22,0xC2,0xAF,0xAB,0x07,0xAA,0x06,0x8A,
+0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,0xA5,0x75,
+0xA0,0x03,0x00,0x00,0x00,0xAA,0xA1,0xBA,
+0x00,0xF8,0xD2,0xAF,0x22,0x7F,0x0C,0x7E,
+0x13,0x12,0x06,0xC3,0xEF,0x44,0x50,0xFD,
+0xAC,0x06,0x7F,0x0C,0x7E,0x13,0x02,0x06,
+0xE7,0x12,0x07,0x03,0x12,0x07,0x2E,0x12,
+0x04,0x2C,0x02,0x00,0x03,0x42,0x06,0x33,
+0x00,0x00,0x42,0x06,0x31,0x00,0x00,0x00,
+0xE4,0xF5,0x8E,0x22};
+
 
 struct rtl8367b_initval {
 	u16 reg;
@@ -319,6 +774,34 @@ rtl8367b_mib_counters[RTL8367B_NUM_MIB_COUNTERS] = {
 		if (err)						\
 			return err;					\
 	} while (0)
+		
+#define REG_RWBTS(_smi, _reg, _bits, _val)				\
+			do {								\
+				err = rtl8366_smi_rwbts(_smi, _reg, _bits, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+		
+#define REG_RWBT(_smi, _reg, _bit, _val)				\
+			do {								\
+				err = rtl8366_smi_rwbt(_smi, _reg, _bit, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+				
+#define REG_RDBT(_smi, _reg, _bit, _val)				\
+			do {								\
+				err = rtl8366_smi_rdbt(_smi, _reg, _bit, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
+				
+#define REG_RDBTS(_smi, _reg, _bits, _val)				\
+			do {								\
+				err = rtl8366_smi_rdbts(_smi, _reg, _bits, _val);	\
+				if (err)						\
+					return err; 				\
+			} while (0)
 
 static const struct rtl8367b_initval rtl8367r_vb_initvals_0[] = {
 	{0x1B03, 0x0876}, {0x1200, 0x7FC4}, {0x0301, 0x0026}, {0x1722, 0x0E14},
@@ -574,6 +1057,20 @@ static const struct rtl8367b_initval rtl8367r_vb_initvals_1[] = {
 	{0x133E, 0x000E}, {0x133F, 0x0010},
 };
 
+static const struct rtl8367b_initval rtl8367s_initvals0[] = {
+	{0x13c2, 0x0000}, {0x0018, 0x0f00}, {0x0038, 0x0f00}, {0x0058, 0x0f00},
+	{0x0078, 0x0f00}, {0x0098, 0x0f00}, {0x1d15, 0x0a69}, {0x2000, 0x1340},
+	{0x2020, 0x1340}, {0x2040, 0x1340}, {0x2060, 0x1340}, {0x2080, 0x1340},
+	{0x13eb, 0x15bb}, {0x1303, 0x06d6}, {0x1304, 0x0700}, {0x13E2, 0x003F},
+	{0x13F9, 0x0090}, {0x121e, 0x03CA}, {0x1233, 0x0352}, {0x1237, 0x00a0},
+	{0x123a, 0x0030}, {0x1239, 0x0084}, {0x0301, 0x1000}, {0x1349, 0x001F},
+	{0x18e0, 0x4004}, {0x122b, 0x641c}, {0x1305, 0xc000}, {0x1200, 0x7fcb},
+	{0x0884, 0x0003}, {0x06eb, 0x0001}, {0x00cf, 0xffff}, {0x00d0, 0x0007},
+	{0x00ce, 0x48b0}, {0x00ce, 0x48b0}, {0x0398, 0xffff}, {0x0399, 0x0007},
+	{0x0300, 0x0001}, {0x03fa, 0x0007}, {0x08c8, 0x00c0}, {0x0a30, 0x020e},
+	{0x0800, 0x0000}, {0x0802, 0x0000}, {0x09da, 0x0017}, {0x1d32, 0x0002},
+};
+
 static int rtl8367b_write_initvals(struct rtl8366_smi *smi,
 				  const struct rtl8367b_initval *initvals,
 				  int count)
@@ -696,6 +1193,11 @@ static int rtl8367b_init_regs(struct rtl8366_smi *smi)
 	rlvid = (chip_ver >> RTL8367B_CHIP_VER_RLVID_SHIFT) &
 		RTL8367B_CHIP_VER_RLVID_MASK;
 
+	if (of_device_is_compatible(smi->parent->of_node,
+				    "realtek,rtl8367s")) {
+		initvals = rtl8367s_initvals0;
+		count = ARRAY_SIZE(rtl8367s_initvals0);
+	} else {
 	switch (rlvid) {
 	case 0:
 		initvals = rtl8367r_vb_initvals_0;
@@ -710,6 +1212,7 @@ static int rtl8367b_init_regs(struct rtl8366_smi *smi)
 	default:
 		dev_err(smi->parent, "unknow rlvid %u\n", rlvid);
 		return -ENODEV;
+		}
 	}
 
 	/* TODO: disable RLTP */
@@ -782,6 +1285,7 @@ static int rtl8367b_extif_set_mode(struct rtl8366_smi *smi, int id,
 		return -EINVAL;
 	}
 
+
 	REG_RMW(smi, RTL8367B_DIS_REG,
 		RTL8367B_DIS_RGMII_MASK << RTL8367B_DIS_RGMII_SHIFT(id),
 		mode << RTL8367B_DIS_RGMII_SHIFT(id));
@@ -817,6 +1321,336 @@ static int rtl8367b_extif_set_force(struct rtl8366_smi *smi, int id,
 	return 0;
 }
 
+
+int rtl8367s_setAsicPortForceLinkExt(struct rtl8366_smi *smi, u32 id, struct rtl8367_port_ability *pPortAbility)
+{
+    u32  regValue;
+    u32 reg_data = 0;
+	int err;
+
+    reg_data |= pPortAbility->force_mode << 12;
+//    reg_data |= pPortAbility->mstfault << 9;
+//    reg_data |= pPortAbility->mstmode << 8;
+    reg_data |= pPortAbility->nway << 7;
+    reg_data |= pPortAbility->txpause << 6;
+    reg_data |= pPortAbility->rxpause << 5;
+    reg_data |= pPortAbility->link << 4;
+    reg_data |= pPortAbility->duplex << 2;
+    reg_data |= pPortAbility->speed;
+
+  
+        if(1 == id)
+        {
+            REG_RD(smi, RTL8367S_REG_REG_TO_ECO4, &regValue);
+            if((regValue & (0x0001 << 5)) && (regValue & (0x0001 << 7)))
+                return 0;
+
+            REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_FDUP_OFFSET, pPortAbility->duplex);
+            REG_RWBTS(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_SPD_MASK, pPortAbility->speed);
+            REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_LINK_OFFSET, pPortAbility->link);
+            REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_TXFC_OFFSET, pPortAbility->txpause);
+            REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_RXFC_OFFSET, pPortAbility->rxpause);
+
+        }
+
+        if(0 == id || 1 == id)
+            REG_WR(smi, RTL8367S_REG_DIGITAL_INTERFACE0_FORCE + id, reg_data);
+        else
+            REG_WR(smi, RTL8367S_REG_DIGITAL_INTERFACE2_FORCE, reg_data);
+
+
+    return 0;
+}
+
+int rtl8367s_getAsicPortForceLinkExt(struct rtl8366_smi *smi, u32 id, struct rtl8367_port_ability *pPortAbility)
+{
+    u32  reg_data;
+    u32  sgmiiSel;
+    u32  hsgmiiSel;
+	int err;
+
+
+        if(1 == id)
+        {
+            REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII_OFFSET, &sgmiiSel);               
+            REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_OFFSET, &hsgmiiSel);               
+            if( (sgmiiSel == 1) || (hsgmiiSel == 1) )
+            {
+                memset(pPortAbility, 0x00, sizeof(struct rtl8367_port_ability));
+                pPortAbility->force_mode = 1;
+                REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_FDUP_OFFSET, &reg_data);                   
+                pPortAbility->duplex = reg_data;
+                REG_RDBTS(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_SPD_MASK, &reg_data);                   
+                pPortAbility->speed = reg_data;
+                REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_LINK_OFFSET, &reg_data);                   
+                pPortAbility->link = reg_data;
+                REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_TXFC_OFFSET, &reg_data);                  
+                pPortAbility->txpause = reg_data;
+                REG_RDBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_SGMII_RXFC_OFFSET, &reg_data);                   
+                pPortAbility->rxpause = reg_data;
+                return 0;
+            }
+        }
+
+        if(0 == id || 1 == id)
+            REG_RD(smi, RTL8367S_REG_DIGITAL_INTERFACE0_FORCE+id, &reg_data);
+        else
+            REG_RD(smi, RTL8367S_REG_DIGITAL_INTERFACE2_FORCE, &reg_data);
+  
+        pPortAbility->force_mode = (reg_data >> 12) & 0x0001;
+//        pPortAbility->mstfault  = (reg_data >> 9) & 0x0001;
+//        pPortAbility->mstmode   = (reg_data >> 8) & 0x0001;
+        pPortAbility->nway      = (reg_data >> 7) & 0x0001;
+        pPortAbility->txpause   = (reg_data >> 6) & 0x0001;
+        pPortAbility->rxpause   = (reg_data >> 5) & 0x0001;
+        pPortAbility->link      = (reg_data >> 4) & 0x0001;
+        pPortAbility->duplex    = (reg_data >> 2) & 0x0001;
+        pPortAbility->speed     = reg_data & 0x0003;
+    
+    return 0;
+}
+
+int rtl8367s_setAsicPortExtMode(struct rtl8366_smi *smi, u32 id, u32 mode)
+{
+    u32 i, option, regValue;
+    u32 idx;
+	int err;
+    u32 redData[][2] =   { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x21A2, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    u32 redDataSB[][2] = { {0x04D7, 0x0480}, {0xF994, 0x0481}, {0x2420, 0x0482}, {0x6960, 0x0483}, {0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E} };
+    u32 redData1[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData5[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData6[][2] =  { {0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData8[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redData9[][2] =  { {0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+    u32 redDataHB[][2] = { {0x82F0, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x7960, 0x0503}, {0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001}, {0x83F2, 0x002E} };
+
+
+	printk("======mode 2==============\n");
+  
+        if(mode == RTL8367S_EXTIF_MODE_1000X)
+        {
+            REG_RWBT(smi, RTL8367S_REG_REG_TO_ECO4, 5, 1);
+            REG_RWBT(smi, RTL8367S_REG_REG_TO_ECO4, 7, 1);             
+            REG_RWBT(smi, RTL8367S_REG_CHIP_RESET, RTL8367S_DW8051_RST_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367S_REG_MISCELLANEOUS_CONFIGURE0, RTL8367S_DW8051_EN_OFFSET, 1);       
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_ACS_IROM_ENABLE_OFFSET, 1);
+			REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_IROM_MSB_OFFSET, 0);
+       
+      
+                for(idx = 0; idx < FIBER2_1G_INIT_SIZE; idx++)
+                {
+                    REG_WR(smi, 0xE000 + idx, (u32)Fiber2_1G[idx]);                      
+                }
+
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_IROM_MSB_OFFSET, 0);              
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_ACS_IROM_ENABLE_OFFSET, 0);               
+            REG_RWBT(smi, RTL8367S_REG_CHIP_RESET, RTL8367S_DW8051_RST_OFFSET, 0);               
+        }
+
+       
+        /* Serdes reset */
+//        if( (mode == RTL8367C_EXT_TMII_MAC) || (mode == RTL8367C_EXT_TMII_PHY) )
+ //       {
+  //          REG_RWBT(smi, RTL8367S_REG_BYPASS_LINE_RATE, id, 1);              
+ //       }
+ //       else
+ //       {
+			REG_RWBT(smi, RTL8367S_REG_BYPASS_LINE_RATE, id, 0);               
+ //       }
+        if( (mode == RTL8367S_EXTIF_MODE_SGMII) || (mode == RTL8367S_EXTIF_MODE_HSGMII) )
+        {
+            REG_WR(smi, 0x13C0, 0x0249);
+            REG_RD(smi, 0x13C1, &option);              
+            REG_WR(smi, 0x13C0, 0x0000);               
+        }
+        if(mode == RTL8367S_EXTIF_MODE_SGMII)
+        {
+            if(option == 0)
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData[i][0]);                      
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData[i][1]);                       
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                      
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 7; i++)
+                {
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redDataSB[i][0]);                      
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redDataSB[i][1]);                      
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                       
+                }
+            }
+        }
+        if(mode == RTL8367S_EXTIF_MODE_HSGMII)
+        {
+            if(option == 0)
+            {
+                REG_WR(smi, 0x13c2, 0x0249);                  
+                REG_RD(smi, 0x1301, &regValue);                  
+                REG_WR(smi, 0x13c2, 0x0000);                  
+                if ( ((regValue & 0x00F0) >> 4) == 0x0001)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData1[i][0]);                          
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData1[i][1]);                          
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0005)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+						REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData5[i][0]);								
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData5[i][1]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0006)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+						REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData6[i][0]);
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData6[i][1]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0008)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData8[i][0]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData8[i][1]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                           
+                    }
+                }
+                else if ( ((regValue & 0x00F0) >> 4) == 0x0009)
+                {
+                    for(i = 0; i <= 8; i++)
+                    {
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redData9[i][0]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redData9[i][1]);                           
+                        REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);                          
+                    }
+                }
+            }
+            else
+            {
+                for(i = 0; i <= 8; i++)
+                {
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, redDataHB[i][0]);                       
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, redDataHB[i][1]);                       
+                    REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);
+                       
+                }
+            }
+        }
+
+        /* Only one ext port should care SGMII setting */
+        if(id == 1)
+        {
+            if(mode == RTL8367S_EXTIF_MODE_SGMII)
+            {
+                REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII_OFFSET, 1);                   
+                REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_OFFSET, 0);                   
+            }
+            else if(mode == RTL8367S_EXTIF_MODE_HSGMII)
+            {
+                REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII_OFFSET, 0);                   
+                REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_OFFSET, 1);                   
+            }
+            else
+            {
+                if(mode != RTL8367S_EXTIF_MODE_1000X)
+                {
+                    REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_SGMII_OFFSET, 0);                       
+                    REG_RWBT(smi, RTL8367S_REG_SDS_MISC, RTL8367S_CFG_MAC8_SEL_HSGMII_OFFSET, 0);                       
+                }
+            }
+        }
+
+        if(0 == id || 1 == id)
+        {
+            REG_RWBTS(smi, RTL8367S_REG_DIGITAL_INTERFACE_SELECT, RTL8367S_SELECT_GMII_0_MASK << (id * RTL8367S_SELECT_GMII_1_OFFSET), mode);               
+        }
+        else
+        {
+            REG_RWBTS(smi, RTL8367S_REG_DIGITAL_INTERFACE_SELECT_1, RTL8367S_SELECT_GMII_2_MASK, mode);               
+        }
+
+        /* Serdes not reset */
+        if( (mode == RTL8367S_EXTIF_MODE_SGMII) || (mode == RTL8367S_EXTIF_MODE_HSGMII) )
+        {
+            REG_WR(smi, RTL8367S_REG_SDS_INDACS_DATA, 0x7106);               
+            REG_WR(smi, RTL8367S_REG_SDS_INDACS_ADR, 0x0003);              
+            REG_WR(smi, RTL8367S_REG_SDS_INDACS_CMD, 0x00C0);               
+        }
+
+        if( (mode == RTL8367S_EXTIF_MODE_SGMII) || (mode == RTL8367S_EXTIF_MODE_HSGMII) )
+        {
+            REG_RWBT(smi, RTL8367S_REG_CHIP_RESET, RTL8367S_DW8051_RST_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367S_REG_MISCELLANEOUS_CONFIGURE0, RTL8367S_DW8051_EN_OFFSET, 1);              
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_ACS_IROM_ENABLE_OFFSET, 1);               
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_IROM_MSB_OFFSET, 0);              
+            for(idx = 0; idx < SGMII_INIT_SIZE; idx++)
+            {
+                REG_WR(smi, 0xE000 + idx, (u32)Sgmii_Init[idx]);                  
+            }
+
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_IROM_MSB_OFFSET, 0);               
+            REG_RWBT(smi, RTL8367S_REG_DW8051_RDY, RTL8367S_ACS_IROM_ENABLE_OFFSET, 0);              
+            REG_RWBT(smi, RTL8367S_REG_CHIP_RESET, RTL8367S_DW8051_RST_OFFSET, 0);              
+        }
+
+    return 0;
+}
+
+
+
+static int rtl8367s_extif_set_force(struct rtl8366_smi *smi, int id, int mode, 
+				   struct rtl8367_port_ability *pa)
+{
+	int retVal;
+    struct rtl8367_port_ability ability;
+    u32 ext_id;
+
+    ext_id = 1;
+
+    if(mode == RTL8367_EXTIF_MODE_DISABLED)
+    {
+        memset(&ability, 0x00, sizeof(struct rtl8367_port_ability));
+        if ((retVal = rtl8367s_setAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+
+        if ((retVal = rtl8367s_setAsicPortExtMode(smi, ext_id, mode)) != 0)
+            return retVal;
+    }
+	
+    else
+    {
+        if ((retVal = rtl8367s_setAsicPortExtMode(smi, ext_id, mode)) != 0)
+            return retVal;
+        if ((retVal = rtl8367s_getAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+
+        ability.force_mode = pa->force_mode;
+        ability.speed     = pa->speed;
+        ability.duplex    = pa->duplex;
+        ability.link      = pa->link;
+        ability.nway      = pa->nway;
+        ability.txpause   = pa->txpause;
+        ability.rxpause   = pa->rxpause;
+
+        if ((retVal = rtl8367s_setAsicPortForceLinkExt(smi, ext_id, &ability)) != 0)
+            return retVal;
+    }
+
+    return 0;
+}
+
 static int rtl8367b_extif_set_rgmii_delay(struct rtl8366_smi *smi, int id,
 					 unsigned txdelay, unsigned rxdelay)
 {
@@ -844,12 +1678,18 @@ static int rtl8367b_extif_init(struct rtl8366_smi *smi, int id,
 
 	mode = (cfg) ? cfg->mode : RTL8367_EXTIF_MODE_DISABLED;
 
-	err = rtl8367b_extif_set_mode(smi, id, mode);
-	if (err)
-		return err;
-
+	if (!of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+	{
+		err = rtl8367b_extif_set_mode(smi, id, mode);
+		if (err)
+			return err;
+	}
+	
 	if (mode != RTL8367_EXTIF_MODE_DISABLED) {
-		err = rtl8367b_extif_set_force(smi, id, &cfg->ability);
+		if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+			err = rtl8367s_extif_set_force(smi, id, mode, &cfg->ability);
+		else
+			err = rtl8367b_extif_set_force(smi, id, &cfg->ability);
 		if (err)
 			return err;
 
@@ -1208,12 +2048,16 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 				    struct switch_port_link *link)
 {
 	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
-	u32 data = 0;
+	u32 data = 0, sds_misc = 0;
 	u32 speed;
 
 	if (port >= RTL8367B_NUM_PORTS)
 		return -EINVAL;
 
+	if (port == 6 &&
+		of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s"))
+		rtl8366_smi_read_reg(smi, RTL8367S_SDS_MISC, &sds_misc);
+
 	rtl8366_smi_read_reg(smi, RTL8367B_PORT_STATUS_REG(port), &data);
 
 	link->link = !!(data & RTL8367B_PORT_STATUS_LINK);
@@ -1234,7 +2078,10 @@ static int rtl8367b_sw_get_port_link(struct switch_dev *dev,
 		link->speed = SWITCH_PORT_SPEED_100;
 		break;
 	case 2:
-		link->speed = SWITCH_PORT_SPEED_1000;
+		link->speed = (((sds_misc & RTL8367S_CFG_MAC8_SEL_HSGMII_MASK)
+				>> RTL8367S_CFG_MAC8_SEL_HSGMII_SHIFT) == 1)
+				? SWITCH_PORT_SPEED_2500
+				: SWITCH_PORT_SPEED_1000;
 		break;
 	default:
 		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
@@ -1302,6 +2149,7 @@ static int rtl8367b_sw_reset_port_mibs(struct switch_dev *dev,
 				RTL8367B_MIB_CTRL0_PORT_RESET_MASK(port % 8));
 }
 
+
 static struct switch_attr rtl8367b_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
@@ -1390,7 +2238,7 @@ static int rtl8367b_switch_init(struct rtl8366_smi *smi)
 	int err;
 
 	dev->name = "RTL8367B";
-	dev->cpu_port = RTL8367B_CPU_PORT_NUM;
+	dev->cpu_port = smi->cpu_port;
 	dev->ports = RTL8367B_NUM_PORTS;
 	dev->vlans = RTL8367B_NUM_VIDS;
 	dev->ops = &rtl8367b_sw_ops;
@@ -1470,6 +2318,11 @@ static int rtl8367b_detect(struct rtl8366_smi *smi)
 		return ret;
 	}
 
+	/* rtl8367s: known chip num:6367 ver:00a0, mode:00a0 */
+
+	if (of_device_is_compatible(smi->parent->of_node, "realtek,rtl8367s")) {
+			chip_name = "8367S";
+	} else {
 	switch (chip_ver) {
 	case 0x1000:
 		chip_name = "8367RB";
@@ -1482,6 +2335,7 @@ static int rtl8367b_detect(struct rtl8366_smi *smi)
 			"unknown chip num:%04x ver:%04x, mode:%04x\n",
 			chip_num, chip_ver, chip_mode);
 		return -ENODEV;
+		}
 	}
 
 	dev_info(smi->parent, "RTL%s chip found\n", chip_name);
@@ -1516,14 +2370,19 @@ static int  rtl8367b_probe(struct platform_device *pdev)
 	int err;
 
 	smi = rtl8366_smi_probe(pdev);
-	if (!smi)
-		return -ENODEV;
+	if (IS_ERR(smi))
+		return PTR_ERR(smi);
 
 	smi->clk_delay = 1500;
 	smi->cmd_read = 0xb9;
 	smi->cmd_write = 0xb8;
+
 	smi->ops = &rtl8367b_smi_ops;
-	smi->cpu_port = RTL8367B_CPU_PORT_NUM;
+	if (of_device_is_compatible(pdev->dev.of_node, "realtek,rtl8367s"))
+		smi->cpu_port = RTL8367S_CPU_PORT_NUM;
+	else
+		smi->cpu_port = RTL8367B_CPU_PORT_NUM;
+
 	smi->num_ports = RTL8367B_NUM_PORTS;
 	smi->num_vlan_mc = RTL8367B_NUM_VLANS;
 	smi->mib_counters = rtl8367b_mib_counters;
@@ -1575,6 +2434,7 @@ static void rtl8367b_shutdown(struct platform_device *pdev)
 static const struct of_device_id rtl8367b_match[] = {
 	{ .compatible = "realtek,rtl8367b" },
 	{ .compatible = "rtl8367b" },
+	{ .compatible = "realtek,rtl8367s" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rtl8367b_match);
--- a/drivers/net/phy/rtl8366_smi.h	2023-03-21 09:29:19.422575683 +0800
+++ b/drivers/net/phy/rtl8366_smi.h	2023-03-20 08:55:48.041464368 +0800
@@ -14,6 +14,7 @@
 #include <linux/phy.h>
 #include <linux/switch.h>
 #include <linux/platform_device.h>
+#include <linux/reset.h>
 
 struct rtl8366_smi_ops;
 struct rtl8366_vlan_ops;
@@ -33,7 +34,7 @@ struct rtl8366_smi {
 	struct device		*parent;
 	unsigned int		gpio_sda;
 	unsigned int		gpio_sck;
-	void			(*hw_reset)(bool active);
+	void			(*hw_reset)(struct rtl8366_smi *smi, bool active);
 	unsigned int		clk_delay;	/* ns */
 	u8			cmd_read;
 	u8			cmd_write;
@@ -54,11 +55,16 @@ struct rtl8366_smi {
 	int			vlan4k_enabled;
 
 	char			buf[4096];
+
+	struct reset_control	*reset;
+
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
 	struct dentry           *debugfs_root;
 	u16			dbg_reg;
 	u8			dbg_vlan_4k_page;
 #endif
+	struct mii_bus		*ext_mbus;
+	u32 phy_addr;
 };
 
 struct rtl8366_vlan_mc {
@@ -109,6 +115,10 @@ int rtl8366_smi_write_reg(struct rtl8366
 int rtl8366_smi_write_reg_noack(struct rtl8366_smi *smi, u32 addr, u32 data);
 int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data);
 int rtl8366_smi_rmwr(struct rtl8366_smi *smi, u32 addr, u32 mask, u32 data);
+int rtl8366_smi_rwbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 value);
+int rtl8366_smi_rwbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 value);
+int rtl8366_smi_rdbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 *value);
+int rtl8366_smi_rdbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 *value);
 
 int rtl8366_reset_vlan(struct rtl8366_smi *smi);
 int rtl8366_enable_vlan(struct rtl8366_smi *smi, int enable);
@@ -146,6 +156,9 @@ int rtl8366_sw_get_vlan_enable(struct sw
 int rtl8366_sw_set_vlan_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val);
+int rtl8366_sw_get_port_stats(struct switch_dev *dev, int port,
+				struct switch_port_stats *stats,
+				int txb_id, int rxb_id);
 
 struct rtl8366_smi* rtl8366_smi_probe(struct platform_device *pdev);

--- a/drivers/net/phy/rtl8366_smi.c	2023-03-21 09:28:56.426383208 +0800
+++ b/drivers/net/phy/rtl8366_smi.c	2023-03-21 09:15:07.869753295 +0800
@@ -19,6 +19,8 @@
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
 #include <linux/rtl8366.h>
+#include <linux/version.h>
+#include <linux/of_mdio.h>
 
 #ifdef CONFIG_RTL8366_SMI_DEBUG_FS
 #include <linux/debugfs.h>
@@ -197,7 +199,7 @@ static int rtl8366_smi_read_byte1(struct rtl8366_smi *smi, u8 *data)
 	return 0;
 }
 
-int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+static int __rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 {
 	unsigned long flags;
 	u8 lo = 0;
@@ -238,6 +240,101 @@ int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
 
 	return ret;
 }
+/* Read/write via mdiobus */
+#define MDC_MDIO_CTRL0_REG		31
+#define MDC_MDIO_START_REG		29
+#define MDC_MDIO_CTRL1_REG		21
+#define MDC_MDIO_ADDRESS_REG		23
+#define MDC_MDIO_DATA_WRITE_REG		24
+#define MDC_MDIO_DATA_READ_REG		25
+
+#define MDC_MDIO_START_OP		0xFFFF
+#define MDC_MDIO_ADDR_OP		0x000E
+#define MDC_MDIO_READ_OP		0x0001
+#define MDC_MDIO_WRITE_OP		0x0003
+#define MDC_REALTEK_PHY_ADDR		0
+
+int __rtl8366_mdio_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+{
+	u32 phy_id = smi->phy_addr?smi->phy_addr:MDC_REALTEK_PHY_ADDR;
+	struct mii_bus *mbus = smi->ext_mbus;
+
+	BUG_ON(in_interrupt());
+
+	mutex_lock(&mbus->mdio_lock);
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address control code to register 31 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address to register 23 */
+	mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write read control code to register 21 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_READ_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(smi->ext_mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Read data from register 25 */
+	*data = mbus->read(mbus, phy_id, MDC_MDIO_DATA_READ_REG);
+
+	mutex_unlock(&mbus->mdio_lock);
+
+	return 0;
+}
+
+static int __rtl8366_mdio_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
+{
+	u32 phy_id = smi->phy_addr?smi->phy_addr:MDC_REALTEK_PHY_ADDR;
+	struct mii_bus *mbus = smi->ext_mbus;
+
+	BUG_ON(in_interrupt());
+
+	mutex_lock(&mbus->mdio_lock);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address control code to register 31 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL0_REG, MDC_MDIO_ADDR_OP);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write address to register 23 */
+	mbus->write(mbus, phy_id, MDC_MDIO_ADDRESS_REG, addr);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write data to register 24 */
+	mbus->write(mbus, phy_id, MDC_MDIO_DATA_WRITE_REG, data);
+
+	/* Write Start command to register 29 */
+	mbus->write(mbus, phy_id, MDC_MDIO_START_REG, MDC_MDIO_START_OP);
+
+	/* Write data control code to register 21 */
+	mbus->write(mbus, phy_id, MDC_MDIO_CTRL1_REG, MDC_MDIO_WRITE_OP);
+
+	mutex_unlock(&mbus->mdio_lock);
+	return 0;
+}
+
+int rtl8366_smi_read_reg(struct rtl8366_smi *smi, u32 addr, u32 *data)
+{
+	if (smi->ext_mbus)
+		return __rtl8366_mdio_read_reg(smi, addr, data);
+	else
+		return __rtl8366_smi_read_reg(smi, addr, data);
+}
 EXPORT_SYMBOL_GPL(rtl8366_smi_read_reg);
 
 static int __rtl8366_smi_write_reg(struct rtl8366_smi *smi,
@@ -289,7 +386,10 @@ static int __rtl8366_smi_write_reg(struct rtl8366_smi *smi,
 
 int rtl8366_smi_write_reg(struct rtl8366_smi *smi, u32 addr, u32 data)
 {
-	return __rtl8366_smi_write_reg(smi, addr, data, true);
+	if (smi->ext_mbus)
+		return __rtl8366_mdio_write_reg(smi, addr, data);
+	else
+		return __rtl8366_smi_write_reg(smi, addr, data, true);
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_write_reg);
 
@@ -314,12 +414,98 @@ int rtl8366_smi_rmwr(struct rtl8366_smi *smi, u32 addr, u32 mask, u32 data)
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_rmwr);
 
+
+int rtl8366_smi_rwbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 value)
+{
+	u32 t;
+    int err;
+
+    err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    if(value)
+        t = t | (1 << bit);
+    else
+        t = t & (~(1 << bit));
+
+    err = rtl8366_smi_write_reg(smi, addr, t);
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rwbt);
+
+int rtl8366_smi_rdbt(struct rtl8366_smi *smi, u32 addr, u32 bit, u32 *value)
+{
+	u32 t;
+    int err;
+
+	err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    *value = (t & (0x1 << bit)) >> bit;
+
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rdbt);
+
+
+int rtl8366_smi_rwbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 value)
+{
+	u32 t;
+    int err;
+	u32 bitsShift;
+	u32 valueShifted;
+	
+	bitsShift = 0;
+	while(!(bits & (1 << bitsShift)))
+    {
+        bitsShift++;
+    }
+	valueShifted = value << bitsShift;
+
+    err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+
+    t = t & (~bits);
+    t = t | (valueShifted & bits);
+
+    err = rtl8366_smi_write_reg(smi, addr, t);
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rwbts);
+
+int rtl8366_smi_rdbts(struct rtl8366_smi *smi, u32 addr, u32 bits, u32 *value)
+{
+	u32 t;
+    int err;
+
+	u32 bitsShift;
+	
+	bitsShift = 0;
+	while(!(bits & (1 << bitsShift)))
+	{
+		bitsShift++;
+	}
+	
+	err = rtl8366_smi_read_reg(smi, addr, &t);
+    if (err)
+		return err;
+	*value = (t & bits) >> bitsShift;
+
+    return err;
+}
+EXPORT_SYMBOL_GPL(rtl8366_smi_rdbts);
+
+
+
 static int rtl8366_reset(struct rtl8366_smi *smi)
 {
 	if (smi->hw_reset) {
-		smi->hw_reset(true);
+		smi->hw_reset(smi, true);
 		msleep(RTL8366_SMI_HW_STOP_DELAY);
-		smi->hw_reset(false);
+		smi->hw_reset(smi, false);
 		msleep(RTL8366_SMI_HW_START_DELAY);
 		return 0;
 	}
@@ -914,7 +1100,12 @@ static inline void rtl8366_debugfs_remove(struct rtl8366_smi *smi) {}
 static int rtl8366_smi_mii_init(struct rtl8366_smi *smi)
 {
 	int ret;
-	int i;
+
+#ifdef CONFIG_OF
+	struct device_node *np = NULL;
+
+	np = of_get_child_by_name(smi->parent->of_node, "mdio-bus");
+#endif
 
 	smi->mii_bus = mdiobus_alloc();
 	if (smi->mii_bus == NULL) {
@@ -930,11 +1121,14 @@ static int rtl8366_smi_mii_init(struct rtl8366_smi *smi)
 		 dev_name(smi->parent));
 	smi->mii_bus->parent = smi->parent;
 	smi->mii_bus->phy_mask = ~(0x1f);
-	smi->mii_bus->irq = smi->mii_irq;
-	for (i = 0; i < PHY_MAX_ADDR; i++)
-		smi->mii_irq[i] = PHY_POLL;
 
-	ret = mdiobus_register(smi->mii_bus);
+#ifdef CONFIG_OF
+	if (np)
+		ret = of_mdiobus_register(smi->mii_bus, np);
+	else
+#endif
+		ret = mdiobus_register(smi->mii_bus);
+
 	if (ret)
 		goto err_free;
 
@@ -1025,6 +1219,33 @@ int rtl8366_sw_get_port_mib(struct switch_dev *dev,
 }
 EXPORT_SYMBOL_GPL(rtl8366_sw_get_port_mib);
 
+int rtl8366_sw_get_port_stats(struct switch_dev *dev, int port,
+				struct switch_port_stats *stats,
+				int txb_id, int rxb_id)
+{
+	struct rtl8366_smi *smi = sw_to_rtl8366_smi(dev);
+	unsigned long long counter = 0;
+	int ret;
+
+	if (port >= smi->num_ports)
+		return -EINVAL;
+
+	ret = smi->ops->get_mib_counter(smi, txb_id, port, &counter);
+	if (ret)
+		return ret;
+
+	stats->tx_bytes = counter;
+
+	ret = smi->ops->get_mib_counter(smi, rxb_id, port, &counter);
+	if (ret)
+		return ret;
+
+	stats->rx_bytes = counter;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rtl8366_sw_get_port_stats);
+
 int rtl8366_sw_get_vlan_info(struct switch_dev *dev,
 			     const struct switch_attr *attr,
 			     struct switch_val *val)
@@ -1237,25 +1458,27 @@ static int __rtl8366_smi_init(struct rtl8366_smi *smi, const char *name)
 {
 	int err;
 
-	err = gpio_request(smi->gpio_sda, name);
-	if (err) {
-		printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
-			smi->gpio_sda, err);
-		goto err_out;
-	}
+	if (!smi->ext_mbus) {
+		err = gpio_request(smi->gpio_sda, name);
+		if (err) {
+			printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
+				smi->gpio_sda, err);
+			goto err_out;
+		}
 
-	err = gpio_request(smi->gpio_sck, name);
-	if (err) {
-		printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
-			smi->gpio_sck, err);
-		goto err_free_sda;
+		err = gpio_request(smi->gpio_sck, name);
+		if (err) {
+			printk(KERN_ERR "rtl8366_smi: gpio_request failed for %u, err=%d\n",
+				smi->gpio_sck, err);
+			goto err_free_sda;
+		}
 	}
 
 	spin_lock_init(&smi->lock);
 
 	/* start the switch */
 	if (smi->hw_reset) {
-		smi->hw_reset(false);
+		smi->hw_reset(smi, false);
 		msleep(RTL8366_SMI_HW_START_DELAY);
 	}
 
@@ -1270,10 +1493,12 @@ static int __rtl8366_smi_init(struct rtl8366_smi *smi, const char *name)
 static void __rtl8366_smi_cleanup(struct rtl8366_smi *smi)
 {
 	if (smi->hw_reset)
-		smi->hw_reset(true);
+		smi->hw_reset(smi, true);
 
-	gpio_free(smi->gpio_sck);
-	gpio_free(smi->gpio_sda);
+	if (!smi->ext_mbus) {
+		gpio_free(smi->gpio_sck);
+		gpio_free(smi->gpio_sda);
+	}
 }
 
 enum rtl8366_type rtl8366_smi_detect(struct rtl8366_platform_data *pdata)
@@ -1326,8 +1551,11 @@ int rtl8366_smi_init(struct rtl8366_smi *smi)
 	if (err)
 		goto err_out;
 
-	dev_info(smi->parent, "using GPIO pins %u (SDA) and %u (SCK)\n",
-		 smi->gpio_sda, smi->gpio_sck);
+	if (!smi->ext_mbus)
+		dev_info(smi->parent, "using GPIO pins %u (SDA) and %u (SCK)\n",
+			 smi->gpio_sda, smi->gpio_sck);
+	else
+		dev_info(smi->parent, "using MDIO bus '%s'\n", smi->ext_mbus->name);
 
 	err = smi->ops->detect(smi);
 	if (err) {
@@ -1380,18 +1608,62 @@ void rtl8366_smi_cleanup(struct rtl8366_smi *smi)
 EXPORT_SYMBOL_GPL(rtl8366_smi_cleanup);
 
 #ifdef CONFIG_OF
+static void rtl8366_smi_reset(struct rtl8366_smi *smi, bool active)
+{
+	if (active)
+		reset_control_assert(smi->reset);
+	else
+		reset_control_deassert(smi->reset);
+}
+
 int rtl8366_smi_probe_of(struct platform_device *pdev, struct rtl8366_smi *smi)
 {
 	int sck = of_get_named_gpio(pdev->dev.of_node, "gpio-sck", 0);
 	int sda = of_get_named_gpio(pdev->dev.of_node, "gpio-sda", 0);
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *mdio_node;
+	const __be32 *phy_addr;
+	int len;
+	phy_addr = of_get_property(np, "phy-addr", &len);
+	if (!phy_addr || len != sizeof(uint32_t)) {
+		smi->phy_addr  = 0;
+	}else{
+		smi->phy_addr = be32_to_cpup(phy_addr);
+	}
+
+        dev_err(&pdev->dev, "phy addr = %x\n",smi->phy_addr);
 
+
+	mdio_node = of_parse_phandle(np, "mii-bus", 0);
+	if (!mdio_node) {
+		dev_err(&pdev->dev, "cannot find mdio node phandle");
+		goto try_gpio;
+	}
+
+	smi->ext_mbus = of_mdio_find_bus(mdio_node);
+	if (!smi->ext_mbus) {
+		dev_info(&pdev->dev,
+			"cannot find mdio bus from bus handle (yet)");
+		goto try_gpio;
+	}
+
+	return 0;
+
+try_gpio:
 	if (!gpio_is_valid(sck) || !gpio_is_valid(sda)) {
-		dev_err(&pdev->dev, "gpios missing in devictree\n");
-		return -EINVAL;
+		if (!mdio_node) {
+			dev_err(&pdev->dev, "gpios missing in devictree\n");
+			return -EINVAL;
+		} else {
+			return -EPROBE_DEFER;
+		}
 	}
 
 	smi->gpio_sda = sda;
 	smi->gpio_sck = sck;
+	smi->reset = devm_reset_control_get(&pdev->dev, "switch");
+	if (!IS_ERR(smi->reset))
+		smi->hw_reset = rtl8366_smi_reset;
 
 	return 0;
 }
@@ -1440,7 +1712,7 @@ struct rtl8366_smi *rtl8366_smi_probe(struct platform_device *pdev)
 
 free_smi:
 	kfree(smi);
-	return NULL;
+	return ERR_PTR(err);
 }
 EXPORT_SYMBOL_GPL(rtl8366_smi_probe);
 
--- a/include/linux/rtl8367.h
+++ b/include/linux/rtl8367.h
@@ -18,6 +18,8 @@ enum rtl8367_port_speed {
 	RTL8367_PORT_SPEED_10 = 0,
 	RTL8367_PORT_SPEED_100,
 	RTL8367_PORT_SPEED_1000,
+	RTL8367S_PORT_SPEED_500M,
+	RTL8367S_PORT_SPEED_2500M,
 };
 
 struct rtl8367_port_ability {
@@ -39,6 +41,13 @@ enum rtl8367_extif_mode {
 	RTL8367_EXTIF_MODE_TMII_PHY,
 	RTL8367_EXTIF_MODE_GMII,
 	RTL8367_EXTIF_MODE_RGMII_33V,
+	RTL8367B_EXTIF_MODE_RMII_MAC = 7,
+	RTL8367B_EXTIF_MODE_RMII_PHY,
+	RTL8367B_EXTIF_MODE_RGMII_33V,
+	RTL8367S_EXTIF_MODE_1000X = 10,
+	RTL8367S_EXTIF_MODE_SGMII,
+	RTL8367S_EXTIF_MODE_HSGMII,
+	
 };
 
 struct rtl8367_extif_config {