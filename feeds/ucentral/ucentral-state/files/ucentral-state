#!/usr/bin/ucode

'use strict';

import * as libubus from 'ubus';
import * as libuci from 'uci';
import * as uloop from 'uloop';
import * as nl80211 from 'nl80211';
import * as rtnl from 'rtnl';
import * as fs from 'fs';

uloop.init();

let ubus = libubus.connect();
let uci = libuci.cursor();
let config;

let healthcheck;
healthcheck = {
	run: function(delay) {
		if (healthcheck.timer)
			healthcheck.timer.cancel();
		if (healthcheck.pid)
			healthcheck.pid.delete();
		printf('start healthcheck in ' + delay / 1000 + ' seconds\n');
		healthcheck.delay = delay;
		if (delay)
			healthcheck.timer = uloop.timer(delay, healthcheck.spawn)
	},

	complete: function() {
		printf('healtcheck completed\n');
		healthcheck.run(healthcheck.delay);
	},

	spawn: function() {
		printf('healtcheck execute\n');
		healthcheck.pid = uloop.process('/usr/share/ucentral/health.uc', [], {}, healthcheck.complete);
	},
};

let state;
state = {
	run: function(delay) {
		if (state.timer)
			state.timer.cancel();
		if (state.pid)
			state.pid.delete();
		printf('start state in ' + delay / 1000 + ' seconds\n');
		state.delay = delay;
		if (delay)
			state.timer = uloop.timer(delay, state.spawn)
	},

	complete: function() {
		printf('state completed\n');
		state.run(state.delay);
	},

	spawn: function() {
		printf('state execute\n');
		state.pid = uloop.process('/usr/share/ucentral/state.uc', [], {}, state.complete);
	},
};

function config_load() {
	uci.load('ustats');
	config = uci.get_all('ustats');
	healthcheck.run((config?.health?.interval || 0) * 1000);
	state.run((config?.stats?.interval || 0) * 1000);
}

function led_write(led, property, value) {
	let path = '/sys/class/leds/' + led + '/' + property;
	let current = trim(fs.readfile(path));
	if (current == value)
		return;
	let file = fs.open(path, 'w');
	if (!file)
		return;
	file.write(value);
	file.close();
}

function led_find(alias) {
	let path = fs.readfile('/proc/device-tree/aliases/' + alias);
	if (!path)
		return;
	return trim(fs.readfile('/proc/device-tree/' + trim(path) + '/label'));
}

function factory_reset_timeout() {
	let led = led_find('led-running');
	if (led)
		led_write(led, 'trigger', 'default-on');
}

let blink_timer;
function blink_timeout() {
	if (!blink_timer)
		return;
	blink_timer.cancel();
	blink_timer = null;
	system('/etc/init.d/led turnon');
}

let state_handler = {
	connect: function() {
		let led = led_find('led-running');
		if (!led)
			return ubus.STATUS_INVALID_ARGUMENT;
		led_write(led, 'trigger', 'heartbeat');
		return 0;
	},

	online: function() {
		let led = led_find('led-running');
		if (!led)
			return ubus.STATUS_INVALID_ARGUMENT;
		led_write(led, 'trigger', 'default-on');
		return 0;
	},

	'factory-reset': function() {
		let led = led_find('led-running');
		if (!led)
			return ubus.STATUS_INVALID_ARGUMENT;
		led_write(led, 'trigger', 'timer');
		led_write(led, 'delay_on', '100');
		led_write(led, 'delay_off', '100');
		uloop.timer(6000, factory_reset_timeout);
		return 0;	
	},

	blink: function(args) {
		system('/etc/init.d/led blink');
		blink_timer = uloop.timer((args.duration || 10) * 1000, blink_timeout);
		return 0;
	},
};

let ubus_methods = {
	set: {
		call: function(req) {
			if (!state_handler[req.args.state])
				return ubus.STATUS_INVALID_ARGUMENT;
			blink_timeout();
			printf('set state -> ' + req.args.state + '\n');
			
			return state_handler[req.args.state](req.args);
		},
		args: {
			state:'',
			duration: 0
		}
	},

	reload: {
		call: function(req) {
			config_load();
			return 0;
		},
		args: {

		}
	},
};

ubus.publish('state', ubus_methods);
config_load();
uloop.run();
uloop.done();
